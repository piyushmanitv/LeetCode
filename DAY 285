3539. Find Sum of Array Product of Magical Sequences


You are given two integers, m and k, and an integer array nums.

A sequence of integers seq is called magical if:
seq has a size of m.
0 <= seq[i] < nums.length
The binary representation of 2seq[0] + 2seq[1] + ... + 2seq[m - 1] has k set bits.
The array product of this sequence is defined as prod(seq) = (nums[seq[0]] * nums[seq[1]] * ... * nums[seq[m - 1]]).

Return the sum of the array products for all valid magical sequences.

Since the answer may be large, return it modulo 109 + 7.

A set bit refers to a bit in the binary representation of a number that has a value of 1.










constexpr long mod = 1e9 + 7;
class Solution {
public:
    long dp[31][31][16] = {}; 
    int choose[31][31] = {};
    int nCk(int n, int k) {
        if(choose[n][k] == 0) {
            if(k == 0 || k == n) {
                choose[n][k] = 1;
            } else {
                choose[n][k] = nCk(n - 1, k) + nCk(n - 1, k - 1);
                choose[n][n - k] = choose[n][k]; 
            }
        }
        return choose[n][k];
    }
    int magicalSum(int M, int K, vector<int>& nums) {
        dp[0][0][0] = 1;
        const size_t n = nums.size();
        for(int i = 0; i < n; i++) {
            for(int length = M; length >= 0; length--) {
                long power = 1;
                for(int added = 1; added + length <= M; added++) {
                    power = power * nums[i] % mod; 
                    long value = power * nCk(length + added, added) % mod;
                    for(int bits = length; bits >= 0; bits--) {
                        for(int overflow = 0; overflow <= (length - bits)/2; overflow++) {
                            int tail_bits = added + overflow; 
                            dp[length + added][bits + (tail_bits & 1)][tail_bits >> 1] = 
                                (dp[length + added][bits + (tail_bits & 1)][tail_bits >> 1] + dp[length][bits][overflow] * value) % mod;
                        }
                    }
                }
                for(int bits = length; bits >= 0; bits--) {
                    for(int overflow = 1; overflow <= (length - bits)/2; overflow++) {
                        dp[length][bits + (overflow & 1)][overflow >> 1] += dp[length][bits][overflow]; 
                        dp[length][bits][overflow] = 0;
                    }
                }
            }
        }
        long total = 0;
        for(int overflow = 0; overflow <= M/2; overflow++) {
            int overflow_bits = __builtin_popcount(overflow);
            if(overflow_bits <= K) {
                total += dp[M][K - overflow_bits][overflow];
            }
        }
        return total % mod;
    }
};
