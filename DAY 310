3607. Power Grid Maintenance
Solved
Medium

Topics
premium lock icon
Companies

Hint
You are given an integer c representing c power stations, each with a unique identifier id from 1 to c (1‑based indexing).

These stations are interconnected via n bidirectional cables, represented by a 2D array connections, where each element connections[i] = [ui, vi] indicates a connection between station ui and station vi. Stations that are directly or indirectly connected form a power grid.

Initially, all stations are online (operational).

You are also given a 2D array queries, where each query is one of the following two types:

[1, x]: A maintenance check is requested for station x. If station x is online, it resolves the check by itself. If station x is offline, the check is resolved by the operational station with the smallest id in the same power grid as x. If no operational station exists in that grid, return -1.

[2, x]: Station x goes offline (i.e., it becomes non-operational).

Return an array of integers representing the results of each query of type [1, x] in the order they appear.

Note: The power grid preserves its structure; an offline (non‑operational) node remains part of its grid and taking it offline does not alter connectivity.










class UnionFind { // usual UnionFind class
    vector<int> root, rank;
public:
    UnionFind(int N) : root(N+1), rank(N+1, 1){// for 1-indexed 
        iota(root.begin(), root.end(), 0);
    }

    int Find(int x) {//Path compression
        return (x == root[x])?x:root[x] = Find(root[x]);
    }

    bool Union(int x, int y) {//Union by rank
        x= Find(x), y= Find(y);
        if (x==y)
            return 0;
        if (rank[x] > rank[y])
            swap(x, y);
        root[x] = y;
        if (rank[x] == rank[y])
            rank[y]++;
        return 1;
    }
};

class Solution {
public:
    static vector<int> processQueries(int c, vector<vector<int>>& connections, vector<vector<int>>& queries) {
        UnionFind G(c);
        for(auto& e: connections){
            G.Union(e[0], e[1]);
        }
        vector<set<int>> comp(c+1);
        for(int i=1; i<=c; i++){
            comp[G.Find(i)].insert(i);
        }
        vector<int> ans;
        for(auto& q: queries){
            const int t=q[0], x=q[1], rx=G.Find(x);
            auto& C=comp[rx];
            if (t==2)
                C.erase(x);
            else{
                if (C.empty()) ans.push_back(-1);
                else if (C.count(x)) ans.push_back(x);
                else ans.push_back(*C.begin());
            }

        }
        return ans;
    }
};class UnionFind { // usual UnionFind class
    vector<int> root, rank;
public:
    UnionFind(int N) : root(N+1), rank(N+1, 1){// for 1-indexed 
        iota(root.begin(), root.end(), 0);
    }

    int Find(int x) {//Path compression
        return (x == root[x])?x:root[x] = Find(root[x]);
    }

    bool Union(int x, int y) {//Union by rank
        x= Find(x), y= Find(y);
        if (x==y)
            return 0;
        if (rank[x] > rank[y])
            swap(x, y);
        root[x] = y;
        if (rank[x] == rank[y])
            rank[y]++;
        return 1;
    }
};

class Solution {
public:
    static vector<int> processQueries(int c, vector<vector<int>>& connections, vector<vector<int>>& queries) {
        UnionFind G(c);
        for(auto& e: connections){
            G.Union(e[0], e[1]);
        }
        vector<set<int>> comp(c+1);
        for(int i=1; i<=c; i++){
            comp[G.Find(i)].insert(i);
        }
        vector<int> ans;
        for(auto& q: queries){
            const int t=q[0], x=q[1], rx=G.Find(x);
            auto& C=comp[rx];
            if (t==2)
                C.erase(x);
            else{
                if (C.empty()) ans.push_back(-1);
                else if (C.count(x)) ans.push_back(x);
                else ans.push_back(*C.begin());
            }

        }
        return ans;
    }
};

