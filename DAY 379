3454. Separate Squares II

You are given a 2D integer array squares. Each squares[i] = [xi, yi, li] represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.

Find the minimum y-coordinate value of a horizontal line such that the total area covered by squares above the line equals the total area covered by squares below the line.

Answers within 10-5 of the actual answer will be accepted.

Note: Squares may overlap. Overlapping areas should be counted only once in this version.






class Solution {
public:
    bool helper(vector<array<long long,4>>& v,int n,double y){
        if ( y >= v[n-1][1]){
            return false;
        }
        if( y <= v[0][0]){
            return true;
        }

        double up = 0, down = 0;
        int l = 0 , r = n-1 , idx = n;
        while(l<=r) {
            int m = (r+l)/2;
            if(y < v[m][0]) {
                r = m-1;
                idx = m;
            } else {
                l = m+1;
            }
        }
        down = idx>1?v[idx-2][3]:0;
        up = idx!=n?(v[n-1][3]-v[idx-1][3]):0;
        up-=down;
        down=0;
        idx--;
        if(y >= v[idx][0] && y <= v[idx][1]) {
            up += ( v[idx][1] - y )*v[idx][2];
            down += ( y - v[idx][0] )*v[idx][2];
        } else {
            down += v[idx][3] - (idx!=0?v[idx-1][3]:0);
        }

        return up > down;
    }
    double separateSquares(vector<vector<int>>& squares) {
        map<int,vector<array<int,3>>> mp;
        for(auto&a:squares) {                        
            mp[a[1]].push_back({a[0],a[0]+a[2],1});
            mp[a[1]+a[2]].push_back({a[0],a[0]+a[2],0});
        }

        vector<array<long long,4>> v; 
        map<pair<int,int>,int> intervalMap;

        int prev_y = -1;    
        int prev_val = -1;

        for(auto&[y,intervals]:mp) {  
            for(auto & interval : intervals) {
                if(interval[2]) {  
                    intervalMap[{interval[0],interval[1]}]++;
                } else {       
                    intervalMap[{interval[0],interval[1]}]--;
                    if(intervalMap[{interval[0],interval[1]}]==0){
                        intervalMap.erase({interval[0],interval[1]});
                    }
                }
            }

            int ptr1 = -1;  
            int ptr2 = -1;
            int val = 0; 
            for(auto&[interval,b]:intervalMap) {
                if(interval.first > ptr2) {
                    val += ptr2-ptr1;
                    ptr1 = interval.first;
                    ptr2 = interval.second;
                } else {
                    ptr2 = max(ptr2,interval.second);
                }
            }
            val += ptr2-ptr1;
            if(prev_val > 0) {
                v.push_back({prev_y,y,prev_val,(1ll*y-prev_y)*prev_val});
                int tmp = v.size()-1;
                if(tmp > 0){ 
                    v[tmp][3] += v[tmp-1][3];
                }
            }
            prev_y = y;
            prev_val = val;
        }

        int n = v.size();
        
        double l = 0 , r = 2e9;
        for(int k = 0 ; k < 100 ; ++k){

            double m = (l+r)/2.0;

            if(helper(v,n,m)){
                l = m;
            }else{
                r = m;
            }
        }
        return l;
    }
};
