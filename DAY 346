3433. Count Mentions Per User

You are given an integer numberOfUsers representing the total number of users and an array events of size n x 3.

Each events[i] can be either of the following two types:

Message Event: ["MESSAGE", "timestampi", "mentions_stringi"]
This event indicates that a set of users was mentioned in a message at timestampi.
The mentions_stringi string can contain one of the following tokens:
id<number>: where <number> is an integer in range [0,numberOfUsers - 1]. There can be multiple ids separated by a single whitespace and may contain duplicates. This can mention even the offline users.
ALL: mentions all users.
HERE: mentions all online users.
Offline Event: ["OFFLINE", "timestampi", "idi"]
This event indicates that the user idi had become offline at timestampi for 60 time units. The user will automatically be online again at time timestampi + 60.
Return an array mentions where mentions[i] represents the number of mentions the user with id i has across all MESSAGE events.

All users are initially online, and if a user goes offline or comes back online, their status change is processed before handling any message event that occurs at the same timestamp.

Note that a user can be mentioned multiple times in a single message event, and each mention should be counted separately.












#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> countMentions(int numberOfUsers, vector<vector<string>>& events) {
        const int n = numberOfUsers;

        sort(events.begin(), events.end(), [](const vector<string>& a, const vector<string>& b){
            int ta = stoi(a[1]), tb = stoi(b[1]);
            if (ta != tb) return ta < tb;
            bool aOff = (a[0] == "OFFLINE");
            bool bOff = (b[0] == "OFFLINE");
            if (aOff != bOff) return aOff; 
            return false;
        });

        vector<int> ans(n, 0);
        vector<int> nextOnline(n, 0);

        long long allLazy = 0; 
        for (const auto& e : events) {
            const string& type = e[0];
            int t = stoi(e[1]);

            if (type == "OFFLINE") {
                int uid = stoi(e[2]);
                if (uid >= 0 && uid < n) {
                    nextOnline[uid] = max(nextOnline[uid], t + 60);
                }
            } else { 
                const string& msg = e[2];
                if (msg == "ALL") {
                    ++allLazy;
                } else if (msg == "HERE") {
                    for (int i = 0; i < n; ++i) {
                        if (nextOnline[i] <= t) {
                            ++ans[i];
                        }
                    }
                } else {
                    int i = 0, L = (int)msg.size();
                    while (i < L) {
                        while (i < L && msg[i] == ' ') ++i;
                        if (i >= L) break;
                        int j = i;
                        while (j < L && msg[j] != ' ') ++j;
                        if (j - i >= 3 && msg[i] == 'i' && msg[i+1] == 'd') {
                            int k = i + 2, val = 0;
                            bool hasDigit = false;
                            while (k < j && isdigit((unsigned char)msg[k])) {
                                hasDigit = true;
                                val = val * 10 + (msg[k] - '0');
                                ++k;
                            }
                            if (hasDigit && 0 <= val && val < n) {
                                ++ans[val];
                            }
                        }
                        i = j + 1;
                    }
                }
            }
        }
        if (allLazy) {
            for (int i = 0; i < n; ++i) ans[i] += (int)allLazy;
        }
        return ans;
    }
};
